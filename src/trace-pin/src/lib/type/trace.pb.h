// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trace.proto

#ifndef PROTOBUF_trace_2eproto__INCLUDED
#define PROTOBUF_trace_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace trace_format {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_trace_2eproto();
void protobuf_AssignDesc_trace_2eproto();
void protobuf_ShutdownFile_trace_2eproto();

class address_t;
class header_t;
class module_t;
class exception_t;
class metadata_t;
class register_t;
class memory_t;
class call_t;
class sys_open_t;
class sys_read_t;
class sys_write_t;
class sys_generic_t;
class syscall_sup_info_t;
class syscall_t;
class ins_con_info_t;
class instruction_t;
class body_t;
class chunk_t;
class trace_t;

enum architecture_t {
  X86 = 0,
  X86_64 = 1
};
bool architecture_t_IsValid(int value);
const architecture_t architecture_t_MIN = X86;
const architecture_t architecture_t_MAX = X86_64;
const int architecture_t_ARRAYSIZE = architecture_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* architecture_t_descriptor();
inline const ::std::string& architecture_t_Name(architecture_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    architecture_t_descriptor(), value);
}
inline bool architecture_t_Parse(
    const ::std::string& name, architecture_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<architecture_t>(
    architecture_t_descriptor(), name, value);
}
enum typeid_address_t {
  BIT8 = 0,
  BIT16 = 1,
  BIT32 = 2,
  BIT64 = 3,
  BIT128 = 4
};
bool typeid_address_t_IsValid(int value);
const typeid_address_t typeid_address_t_MIN = BIT8;
const typeid_address_t typeid_address_t_MAX = BIT128;
const int typeid_address_t_ARRAYSIZE = typeid_address_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* typeid_address_t_descriptor();
inline const ::std::string& typeid_address_t_Name(typeid_address_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    typeid_address_t_descriptor(), value);
}
inline bool typeid_address_t_Parse(
    const ::std::string& name, typeid_address_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<typeid_address_t>(
    typeid_address_t_descriptor(), name, value);
}
enum typeid_metadata_t {
  EXCEPTION_TYPE = 0,
  MODULE_TYPE = 1,
  WAVE_TYPE = 2
};
bool typeid_metadata_t_IsValid(int value);
const typeid_metadata_t typeid_metadata_t_MIN = EXCEPTION_TYPE;
const typeid_metadata_t typeid_metadata_t_MAX = WAVE_TYPE;
const int typeid_metadata_t_ARRAYSIZE = typeid_metadata_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* typeid_metadata_t_descriptor();
inline const ::std::string& typeid_metadata_t_Name(typeid_metadata_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    typeid_metadata_t_descriptor(), value);
}
inline bool typeid_metadata_t_Parse(
    const ::std::string& name, typeid_metadata_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<typeid_metadata_t>(
    typeid_metadata_t_descriptor(), name, value);
}
enum typeid_syscall_t {
  OPEN_SYSCALL = 0,
  READ_SYSCALL = 1,
  WRITE_SYSCALL = 2,
  GENERIC_SYSCALL = 3
};
bool typeid_syscall_t_IsValid(int value);
const typeid_syscall_t typeid_syscall_t_MIN = OPEN_SYSCALL;
const typeid_syscall_t typeid_syscall_t_MAX = GENERIC_SYSCALL;
const int typeid_syscall_t_ARRAYSIZE = typeid_syscall_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* typeid_syscall_t_descriptor();
inline const ::std::string& typeid_syscall_t_Name(typeid_syscall_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    typeid_syscall_t_descriptor(), value);
}
inline bool typeid_syscall_t_Parse(
    const ::std::string& name, typeid_syscall_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<typeid_syscall_t>(
    typeid_syscall_t_descriptor(), name, value);
}
enum typeid_con_info_t {
  REGREAD = 0,
  REGWRITE = 1,
  MEMLOAD = 2,
  MEMSTORE = 3,
  CALL = 4,
  RET = 5,
  SYSCALL = 6,
  NOT_RETRIEVED = 7,
  COMMENT = 255
};
bool typeid_con_info_t_IsValid(int value);
const typeid_con_info_t typeid_con_info_t_MIN = REGREAD;
const typeid_con_info_t typeid_con_info_t_MAX = COMMENT;
const int typeid_con_info_t_ARRAYSIZE = typeid_con_info_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* typeid_con_info_t_descriptor();
inline const ::std::string& typeid_con_info_t_Name(typeid_con_info_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    typeid_con_info_t_descriptor(), value);
}
inline bool typeid_con_info_t_Parse(
    const ::std::string& name, typeid_con_info_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<typeid_con_info_t>(
    typeid_con_info_t_descriptor(), name, value);
}
enum typeid_body_t {
  METADATA = 0,
  INSTRUCTION = 1
};
bool typeid_body_t_IsValid(int value);
const typeid_body_t typeid_body_t_MIN = METADATA;
const typeid_body_t typeid_body_t_MAX = INSTRUCTION;
const int typeid_body_t_ARRAYSIZE = typeid_body_t_MAX + 1;

const ::google::protobuf::EnumDescriptor* typeid_body_t_descriptor();
inline const ::std::string& typeid_body_t_Name(typeid_body_t value) {
  return ::google::protobuf::internal::NameOfEnum(
    typeid_body_t_descriptor(), value);
}
inline bool typeid_body_t_Parse(
    const ::std::string& name, typeid_body_t* value) {
  return ::google::protobuf::internal::ParseNamedEnum<typeid_body_t>(
    typeid_body_t_descriptor(), name, value);
}
// ===================================================================

class address_t : public ::google::protobuf::Message {
 public:
  address_t();
  virtual ~address_t();

  address_t(const address_t& from);

  inline address_t& operator=(const address_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const address_t& default_instance();

  void Swap(address_t* other);

  // implements Message ----------------------------------------------

  address_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const address_t& from);
  void MergeFrom(const address_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.typeid_address_t typeid = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  inline ::trace_format::typeid_address_t typeid_() const;
  inline void set_typeid_(::trace_format::typeid_address_t value);

  // optional uint32 value_8 = 2;
  inline bool has_value_8() const;
  inline void clear_value_8();
  static const int kValue8FieldNumber = 2;
  inline ::google::protobuf::uint32 value_8() const;
  inline void set_value_8(::google::protobuf::uint32 value);

  // optional uint32 value_16 = 3;
  inline bool has_value_16() const;
  inline void clear_value_16();
  static const int kValue16FieldNumber = 3;
  inline ::google::protobuf::uint32 value_16() const;
  inline void set_value_16(::google::protobuf::uint32 value);

  // optional uint32 value_32 = 4;
  inline bool has_value_32() const;
  inline void clear_value_32();
  static const int kValue32FieldNumber = 4;
  inline ::google::protobuf::uint32 value_32() const;
  inline void set_value_32(::google::protobuf::uint32 value);

  // optional uint64 value_64 = 5;
  inline bool has_value_64() const;
  inline void clear_value_64();
  static const int kValue64FieldNumber = 5;
  inline ::google::protobuf::uint64 value_64() const;
  inline void set_value_64(::google::protobuf::uint64 value);

  // optional bytes value_128 = 6;
  inline bool has_value_128() const;
  inline void clear_value_128();
  static const int kValue128FieldNumber = 6;
  inline const ::std::string& value_128() const;
  inline void set_value_128(const ::std::string& value);
  inline void set_value_128(const char* value);
  inline void set_value_128(const void* value, size_t size);
  inline ::std::string* mutable_value_128();
  inline ::std::string* release_value_128();
  inline void set_allocated_value_128(::std::string* value_128);

  // @@protoc_insertion_point(class_scope:trace_format.address_t)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_value_8();
  inline void clear_has_value_8();
  inline void set_has_value_16();
  inline void clear_has_value_16();
  inline void set_has_value_32();
  inline void clear_has_value_32();
  inline void set_has_value_64();
  inline void clear_has_value_64();
  inline void set_has_value_128();
  inline void clear_has_value_128();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int typeid__;
  ::google::protobuf::uint32 value_8_;
  ::google::protobuf::uint32 value_16_;
  ::google::protobuf::uint32 value_32_;
  ::google::protobuf::uint64 value_64_;
  ::std::string* value_128_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static address_t* default_instance_;
};
// -------------------------------------------------------------------

class header_t : public ::google::protobuf::Message {
 public:
  header_t();
  virtual ~header_t();

  header_t(const header_t& from);

  inline header_t& operator=(const header_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const header_t& default_instance();

  void Swap(header_t* other);

  // implements Message ----------------------------------------------

  header_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const header_t& from);
  void MergeFrom(const header_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.architecture_t architecture = 1;
  inline bool has_architecture() const;
  inline void clear_architecture();
  static const int kArchitectureFieldNumber = 1;
  inline ::trace_format::architecture_t architecture() const;
  inline void set_architecture(::trace_format::architecture_t value);

  // required .trace_format.typeid_address_t address_size = 2;
  inline bool has_address_size() const;
  inline void clear_address_size();
  static const int kAddressSizeFieldNumber = 2;
  inline ::trace_format::typeid_address_t address_size() const;
  inline void set_address_size(::trace_format::typeid_address_t value);

  // @@protoc_insertion_point(class_scope:trace_format.header_t)
 private:
  inline void set_has_architecture();
  inline void clear_has_architecture();
  inline void set_has_address_size();
  inline void clear_has_address_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int architecture_;
  int address_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static header_t* default_instance_;
};
// -------------------------------------------------------------------

class module_t : public ::google::protobuf::Message {
 public:
  module_t();
  virtual ~module_t();

  module_t(const module_t& from);

  inline module_t& operator=(const module_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const module_t& default_instance();

  void Swap(module_t* other);

  // implements Message ----------------------------------------------

  module_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const module_t& from);
  void MergeFrom(const module_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:trace_format.module_t)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static module_t* default_instance_;
};
// -------------------------------------------------------------------

class exception_t : public ::google::protobuf::Message {
 public:
  exception_t();
  virtual ~exception_t();

  exception_t(const exception_t& from);

  inline exception_t& operator=(const exception_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const exception_t& default_instance();

  void Swap(exception_t* other);

  // implements Message ----------------------------------------------

  exception_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const exception_t& from);
  void MergeFrom(const exception_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type_exception = 1;
  inline bool has_type_exception() const;
  inline void clear_type_exception();
  static const int kTypeExceptionFieldNumber = 1;
  inline ::google::protobuf::uint32 type_exception() const;
  inline void set_type_exception(::google::protobuf::uint32 value);

  // required .trace_format.address_t handler = 2;
  inline bool has_handler() const;
  inline void clear_handler();
  static const int kHandlerFieldNumber = 2;
  inline const ::trace_format::address_t& handler() const;
  inline ::trace_format::address_t* mutable_handler();
  inline ::trace_format::address_t* release_handler();
  inline void set_allocated_handler(::trace_format::address_t* handler);

  // @@protoc_insertion_point(class_scope:trace_format.exception_t)
 private:
  inline void set_has_type_exception();
  inline void clear_has_type_exception();
  inline void set_has_handler();
  inline void clear_has_handler();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::address_t* handler_;
  ::google::protobuf::uint32 type_exception_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static exception_t* default_instance_;
};
// -------------------------------------------------------------------

class metadata_t : public ::google::protobuf::Message {
 public:
  metadata_t();
  virtual ~metadata_t();

  metadata_t(const metadata_t& from);

  inline metadata_t& operator=(const metadata_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const metadata_t& default_instance();

  void Swap(metadata_t* other);

  // implements Message ----------------------------------------------

  metadata_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const metadata_t& from);
  void MergeFrom(const metadata_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.typeid_metadata_t typeid = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  inline ::trace_format::typeid_metadata_t typeid_() const;
  inline void set_typeid_(::trace_format::typeid_metadata_t value);

  // optional .trace_format.module_t module_metadata = 2;
  inline bool has_module_metadata() const;
  inline void clear_module_metadata();
  static const int kModuleMetadataFieldNumber = 2;
  inline const ::trace_format::module_t& module_metadata() const;
  inline ::trace_format::module_t* mutable_module_metadata();
  inline ::trace_format::module_t* release_module_metadata();
  inline void set_allocated_module_metadata(::trace_format::module_t* module_metadata);

  // optional .trace_format.exception_t exception_metadata = 3;
  inline bool has_exception_metadata() const;
  inline void clear_exception_metadata();
  static const int kExceptionMetadataFieldNumber = 3;
  inline const ::trace_format::exception_t& exception_metadata() const;
  inline ::trace_format::exception_t* mutable_exception_metadata();
  inline ::trace_format::exception_t* release_exception_metadata();
  inline void set_allocated_exception_metadata(::trace_format::exception_t* exception_metadata);

  // optional uint32 wave_metadata = 4;
  inline bool has_wave_metadata() const;
  inline void clear_wave_metadata();
  static const int kWaveMetadataFieldNumber = 4;
  inline ::google::protobuf::uint32 wave_metadata() const;
  inline void set_wave_metadata(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:trace_format.metadata_t)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_module_metadata();
  inline void clear_has_module_metadata();
  inline void set_has_exception_metadata();
  inline void clear_has_exception_metadata();
  inline void set_has_wave_metadata();
  inline void clear_has_wave_metadata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::module_t* module_metadata_;
  int typeid__;
  ::google::protobuf::uint32 wave_metadata_;
  ::trace_format::exception_t* exception_metadata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static metadata_t* default_instance_;
};
// -------------------------------------------------------------------

class register_t : public ::google::protobuf::Message {
 public:
  register_t();
  virtual ~register_t();

  register_t(const register_t& from);

  inline register_t& operator=(const register_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const register_t& default_instance();

  void Swap(register_t* other);

  // implements Message ----------------------------------------------

  register_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const register_t& from);
  void MergeFrom(const register_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .trace_format.address_t value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::trace_format::address_t& value() const;
  inline ::trace_format::address_t* mutable_value();
  inline ::trace_format::address_t* release_value();
  inline void set_allocated_value(::trace_format::address_t* value);

  // @@protoc_insertion_point(class_scope:trace_format.register_t)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::trace_format::address_t* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static register_t* default_instance_;
};
// -------------------------------------------------------------------

class memory_t : public ::google::protobuf::Message {
 public:
  memory_t();
  virtual ~memory_t();

  memory_t(const memory_t& from);

  inline memory_t& operator=(const memory_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const memory_t& default_instance();

  void Swap(memory_t* other);

  // implements Message ----------------------------------------------

  memory_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const memory_t& from);
  void MergeFrom(const memory_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.address_t address = 1;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 1;
  inline const ::trace_format::address_t& address() const;
  inline ::trace_format::address_t* mutable_address();
  inline ::trace_format::address_t* release_address();
  inline void set_allocated_address(::trace_format::address_t* address);

  // required .trace_format.address_t value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::trace_format::address_t& value() const;
  inline ::trace_format::address_t* mutable_value();
  inline ::trace_format::address_t* release_value();
  inline void set_allocated_value(::trace_format::address_t* value);

  // @@protoc_insertion_point(class_scope:trace_format.memory_t)
 private:
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::address_t* address_;
  ::trace_format::address_t* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static memory_t* default_instance_;
};
// -------------------------------------------------------------------

class call_t : public ::google::protobuf::Message {
 public:
  call_t();
  virtual ~call_t();

  call_t(const call_t& from);

  inline call_t& operator=(const call_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const call_t& default_instance();

  void Swap(call_t* other);

  // implements Message ----------------------------------------------

  call_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const call_t& from);
  void MergeFrom(const call_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.address_t func_addr = 1;
  inline bool has_func_addr() const;
  inline void clear_func_addr();
  static const int kFuncAddrFieldNumber = 1;
  inline const ::trace_format::address_t& func_addr() const;
  inline ::trace_format::address_t* mutable_func_addr();
  inline ::trace_format::address_t* release_func_addr();
  inline void set_allocated_func_addr(::trace_format::address_t* func_addr);

  // required string func_name = 2;
  inline bool has_func_name() const;
  inline void clear_func_name();
  static const int kFuncNameFieldNumber = 2;
  inline const ::std::string& func_name() const;
  inline void set_func_name(const ::std::string& value);
  inline void set_func_name(const char* value);
  inline void set_func_name(const char* value, size_t size);
  inline ::std::string* mutable_func_name();
  inline ::std::string* release_func_name();
  inline void set_allocated_func_name(::std::string* func_name);

  // required bool is_traced = 3;
  inline bool has_is_traced() const;
  inline void clear_is_traced();
  static const int kIsTracedFieldNumber = 3;
  inline bool is_traced() const;
  inline void set_is_traced(bool value);

  // @@protoc_insertion_point(class_scope:trace_format.call_t)
 private:
  inline void set_has_func_addr();
  inline void clear_has_func_addr();
  inline void set_has_func_name();
  inline void clear_has_func_name();
  inline void set_has_is_traced();
  inline void clear_has_is_traced();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::address_t* func_addr_;
  ::std::string* func_name_;
  bool is_traced_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static call_t* default_instance_;
};
// -------------------------------------------------------------------

class sys_open_t : public ::google::protobuf::Message {
 public:
  sys_open_t();
  virtual ~sys_open_t();

  sys_open_t(const sys_open_t& from);

  inline sys_open_t& operator=(const sys_open_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sys_open_t& default_instance();

  void Swap(sys_open_t* other);

  // implements Message ----------------------------------------------

  sys_open_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sys_open_t& from);
  void MergeFrom(const sys_open_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_name = 1;
  inline bool has_file_name() const;
  inline void clear_file_name();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& file_name() const;
  inline void set_file_name(const ::std::string& value);
  inline void set_file_name(const char* value);
  inline void set_file_name(const char* value, size_t size);
  inline ::std::string* mutable_file_name();
  inline ::std::string* release_file_name();
  inline void set_allocated_file_name(::std::string* file_name);

  // required sint32 flags = 2;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 2;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);

  // required uint32 mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // required int32 file_descriptor = 4;
  inline bool has_file_descriptor() const;
  inline void clear_file_descriptor();
  static const int kFileDescriptorFieldNumber = 4;
  inline ::google::protobuf::int32 file_descriptor() const;
  inline void set_file_descriptor(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:trace_format.sys_open_t)
 private:
  inline void set_has_file_name();
  inline void clear_has_file_name();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_file_descriptor();
  inline void clear_has_file_descriptor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_name_;
  ::google::protobuf::int32 flags_;
  ::google::protobuf::uint32 mode_;
  ::google::protobuf::int32 file_descriptor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static sys_open_t* default_instance_;
};
// -------------------------------------------------------------------

class sys_read_t : public ::google::protobuf::Message {
 public:
  sys_read_t();
  virtual ~sys_read_t();

  sys_read_t(const sys_read_t& from);

  inline sys_read_t& operator=(const sys_read_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sys_read_t& default_instance();

  void Swap(sys_read_t* other);

  // implements Message ----------------------------------------------

  sys_read_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sys_read_t& from);
  void MergeFrom(const sys_read_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 file_descriptor = 1;
  inline bool has_file_descriptor() const;
  inline void clear_file_descriptor();
  static const int kFileDescriptorFieldNumber = 1;
  inline ::google::protobuf::uint32 file_descriptor() const;
  inline void set_file_descriptor(::google::protobuf::uint32 value);

  // required .trace_format.address_t buffer_address = 2;
  inline bool has_buffer_address() const;
  inline void clear_buffer_address();
  static const int kBufferAddressFieldNumber = 2;
  inline const ::trace_format::address_t& buffer_address() const;
  inline ::trace_format::address_t* mutable_buffer_address();
  inline ::trace_format::address_t* release_buffer_address();
  inline void set_allocated_buffer_address(::trace_format::address_t* buffer_address);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required bytes buffer_data = 4;
  inline bool has_buffer_data() const;
  inline void clear_buffer_data();
  static const int kBufferDataFieldNumber = 4;
  inline const ::std::string& buffer_data() const;
  inline void set_buffer_data(const ::std::string& value);
  inline void set_buffer_data(const char* value);
  inline void set_buffer_data(const void* value, size_t size);
  inline ::std::string* mutable_buffer_data();
  inline ::std::string* release_buffer_data();
  inline void set_allocated_buffer_data(::std::string* buffer_data);

  // required uint32 count_effective = 5;
  inline bool has_count_effective() const;
  inline void clear_count_effective();
  static const int kCountEffectiveFieldNumber = 5;
  inline ::google::protobuf::uint32 count_effective() const;
  inline void set_count_effective(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:trace_format.sys_read_t)
 private:
  inline void set_has_file_descriptor();
  inline void clear_has_file_descriptor();
  inline void set_has_buffer_address();
  inline void clear_has_buffer_address();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_buffer_data();
  inline void clear_has_buffer_data();
  inline void set_has_count_effective();
  inline void clear_has_count_effective();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::address_t* buffer_address_;
  ::google::protobuf::uint32 file_descriptor_;
  ::google::protobuf::uint32 count_;
  ::std::string* buffer_data_;
  ::google::protobuf::uint32 count_effective_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static sys_read_t* default_instance_;
};
// -------------------------------------------------------------------

class sys_write_t : public ::google::protobuf::Message {
 public:
  sys_write_t();
  virtual ~sys_write_t();

  sys_write_t(const sys_write_t& from);

  inline sys_write_t& operator=(const sys_write_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sys_write_t& default_instance();

  void Swap(sys_write_t* other);

  // implements Message ----------------------------------------------

  sys_write_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sys_write_t& from);
  void MergeFrom(const sys_write_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 file_descriptor = 1;
  inline bool has_file_descriptor() const;
  inline void clear_file_descriptor();
  static const int kFileDescriptorFieldNumber = 1;
  inline ::google::protobuf::uint32 file_descriptor() const;
  inline void set_file_descriptor(::google::protobuf::uint32 value);

  // required .trace_format.address_t buffer_address = 2;
  inline bool has_buffer_address() const;
  inline void clear_buffer_address();
  static const int kBufferAddressFieldNumber = 2;
  inline const ::trace_format::address_t& buffer_address() const;
  inline ::trace_format::address_t* mutable_buffer_address();
  inline ::trace_format::address_t* release_buffer_address();
  inline void set_allocated_buffer_address(::trace_format::address_t* buffer_address);

  // required uint32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // required bytes buffer_data = 4;
  inline bool has_buffer_data() const;
  inline void clear_buffer_data();
  static const int kBufferDataFieldNumber = 4;
  inline const ::std::string& buffer_data() const;
  inline void set_buffer_data(const ::std::string& value);
  inline void set_buffer_data(const char* value);
  inline void set_buffer_data(const void* value, size_t size);
  inline ::std::string* mutable_buffer_data();
  inline ::std::string* release_buffer_data();
  inline void set_allocated_buffer_data(::std::string* buffer_data);

  // required uint32 count_effective = 5;
  inline bool has_count_effective() const;
  inline void clear_count_effective();
  static const int kCountEffectiveFieldNumber = 5;
  inline ::google::protobuf::uint32 count_effective() const;
  inline void set_count_effective(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:trace_format.sys_write_t)
 private:
  inline void set_has_file_descriptor();
  inline void clear_has_file_descriptor();
  inline void set_has_buffer_address();
  inline void clear_has_buffer_address();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_buffer_data();
  inline void clear_has_buffer_data();
  inline void set_has_count_effective();
  inline void clear_has_count_effective();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::address_t* buffer_address_;
  ::google::protobuf::uint32 file_descriptor_;
  ::google::protobuf::uint32 count_;
  ::std::string* buffer_data_;
  ::google::protobuf::uint32 count_effective_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static sys_write_t* default_instance_;
};
// -------------------------------------------------------------------

class sys_generic_t : public ::google::protobuf::Message {
 public:
  sys_generic_t();
  virtual ~sys_generic_t();

  sys_generic_t(const sys_generic_t& from);

  inline sys_generic_t& operator=(const sys_generic_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sys_generic_t& default_instance();

  void Swap(sys_generic_t* other);

  // implements Message ----------------------------------------------

  sys_generic_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const sys_generic_t& from);
  void MergeFrom(const sys_generic_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline ::google::protobuf::uint32 address() const;
  inline void set_address(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:trace_format.sys_generic_t)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 address_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static sys_generic_t* default_instance_;
};
// -------------------------------------------------------------------

class syscall_sup_info_t : public ::google::protobuf::Message {
 public:
  syscall_sup_info_t();
  virtual ~syscall_sup_info_t();

  syscall_sup_info_t(const syscall_sup_info_t& from);

  inline syscall_sup_info_t& operator=(const syscall_sup_info_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const syscall_sup_info_t& default_instance();

  void Swap(syscall_sup_info_t* other);

  // implements Message ----------------------------------------------

  syscall_sup_info_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const syscall_sup_info_t& from);
  void MergeFrom(const syscall_sup_info_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.typeid_syscall_t typeid = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  inline ::trace_format::typeid_syscall_t typeid_() const;
  inline void set_typeid_(::trace_format::typeid_syscall_t value);

  // optional .trace_format.sys_open_t open_syscall = 2;
  inline bool has_open_syscall() const;
  inline void clear_open_syscall();
  static const int kOpenSyscallFieldNumber = 2;
  inline const ::trace_format::sys_open_t& open_syscall() const;
  inline ::trace_format::sys_open_t* mutable_open_syscall();
  inline ::trace_format::sys_open_t* release_open_syscall();
  inline void set_allocated_open_syscall(::trace_format::sys_open_t* open_syscall);

  // optional .trace_format.sys_read_t read_syscall = 3;
  inline bool has_read_syscall() const;
  inline void clear_read_syscall();
  static const int kReadSyscallFieldNumber = 3;
  inline const ::trace_format::sys_read_t& read_syscall() const;
  inline ::trace_format::sys_read_t* mutable_read_syscall();
  inline ::trace_format::sys_read_t* release_read_syscall();
  inline void set_allocated_read_syscall(::trace_format::sys_read_t* read_syscall);

  // optional .trace_format.sys_write_t write_sycall = 4;
  inline bool has_write_sycall() const;
  inline void clear_write_sycall();
  static const int kWriteSycallFieldNumber = 4;
  inline const ::trace_format::sys_write_t& write_sycall() const;
  inline ::trace_format::sys_write_t* mutable_write_sycall();
  inline ::trace_format::sys_write_t* release_write_sycall();
  inline void set_allocated_write_sycall(::trace_format::sys_write_t* write_sycall);

  // optional .trace_format.sys_generic_t generic_sycall = 5;
  inline bool has_generic_sycall() const;
  inline void clear_generic_sycall();
  static const int kGenericSycallFieldNumber = 5;
  inline const ::trace_format::sys_generic_t& generic_sycall() const;
  inline ::trace_format::sys_generic_t* mutable_generic_sycall();
  inline ::trace_format::sys_generic_t* release_generic_sycall();
  inline void set_allocated_generic_sycall(::trace_format::sys_generic_t* generic_sycall);

  // @@protoc_insertion_point(class_scope:trace_format.syscall_sup_info_t)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_open_syscall();
  inline void clear_has_open_syscall();
  inline void set_has_read_syscall();
  inline void clear_has_read_syscall();
  inline void set_has_write_sycall();
  inline void clear_has_write_sycall();
  inline void set_has_generic_sycall();
  inline void clear_has_generic_sycall();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::sys_open_t* open_syscall_;
  ::trace_format::sys_read_t* read_syscall_;
  ::trace_format::sys_write_t* write_sycall_;
  ::trace_format::sys_generic_t* generic_sycall_;
  int typeid__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static syscall_sup_info_t* default_instance_;
};
// -------------------------------------------------------------------

class syscall_t : public ::google::protobuf::Message {
 public:
  syscall_t();
  virtual ~syscall_t();

  syscall_t(const syscall_t& from);

  inline syscall_t& operator=(const syscall_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const syscall_t& default_instance();

  void Swap(syscall_t* other);

  // implements Message ----------------------------------------------

  syscall_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const syscall_t& from);
  void MergeFrom(const syscall_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .trace_format.syscall_sup_info_t info = 2;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 2;
  inline const ::trace_format::syscall_sup_info_t& info() const;
  inline ::trace_format::syscall_sup_info_t* mutable_info();
  inline ::trace_format::syscall_sup_info_t* release_info();
  inline void set_allocated_info(::trace_format::syscall_sup_info_t* info);

  // @@protoc_insertion_point(class_scope:trace_format.syscall_t)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::syscall_sup_info_t* info_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static syscall_t* default_instance_;
};
// -------------------------------------------------------------------

class ins_con_info_t : public ::google::protobuf::Message {
 public:
  ins_con_info_t();
  virtual ~ins_con_info_t();

  ins_con_info_t(const ins_con_info_t& from);

  inline ins_con_info_t& operator=(const ins_con_info_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ins_con_info_t& default_instance();

  void Swap(ins_con_info_t* other);

  // implements Message ----------------------------------------------

  ins_con_info_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ins_con_info_t& from);
  void MergeFrom(const ins_con_info_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.typeid_con_info_t typeid = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  inline ::trace_format::typeid_con_info_t typeid_() const;
  inline void set_typeid_(::trace_format::typeid_con_info_t value);

  // optional .trace_format.register_t read_register = 2;
  inline bool has_read_register() const;
  inline void clear_read_register();
  static const int kReadRegisterFieldNumber = 2;
  inline const ::trace_format::register_t& read_register() const;
  inline ::trace_format::register_t* mutable_read_register();
  inline ::trace_format::register_t* release_read_register();
  inline void set_allocated_read_register(::trace_format::register_t* read_register);

  // optional .trace_format.register_t write_register = 3;
  inline bool has_write_register() const;
  inline void clear_write_register();
  static const int kWriteRegisterFieldNumber = 3;
  inline const ::trace_format::register_t& write_register() const;
  inline ::trace_format::register_t* mutable_write_register();
  inline ::trace_format::register_t* release_write_register();
  inline void set_allocated_write_register(::trace_format::register_t* write_register);

  // optional .trace_format.memory_t load_memory = 4;
  inline bool has_load_memory() const;
  inline void clear_load_memory();
  static const int kLoadMemoryFieldNumber = 4;
  inline const ::trace_format::memory_t& load_memory() const;
  inline ::trace_format::memory_t* mutable_load_memory();
  inline ::trace_format::memory_t* release_load_memory();
  inline void set_allocated_load_memory(::trace_format::memory_t* load_memory);

  // optional .trace_format.memory_t store_memory = 5;
  inline bool has_store_memory() const;
  inline void clear_store_memory();
  static const int kStoreMemoryFieldNumber = 5;
  inline const ::trace_format::memory_t& store_memory() const;
  inline ::trace_format::memory_t* mutable_store_memory();
  inline ::trace_format::memory_t* release_store_memory();
  inline void set_allocated_store_memory(::trace_format::memory_t* store_memory);

  // optional .trace_format.call_t call = 6;
  inline bool has_call() const;
  inline void clear_call();
  static const int kCallFieldNumber = 6;
  inline const ::trace_format::call_t& call() const;
  inline ::trace_format::call_t* mutable_call();
  inline ::trace_format::call_t* release_call();
  inline void set_allocated_call(::trace_format::call_t* call);

  // optional .trace_format.address_t ret_ret_value = 7;
  inline bool has_ret_ret_value() const;
  inline void clear_ret_ret_value();
  static const int kRetRetValueFieldNumber = 7;
  inline const ::trace_format::address_t& ret_ret_value() const;
  inline ::trace_format::address_t* mutable_ret_ret_value();
  inline ::trace_format::address_t* release_ret_ret_value();
  inline void set_allocated_ret_ret_value(::trace_format::address_t* ret_ret_value);

  // optional .trace_format.syscall_t system_call = 8;
  inline bool has_system_call() const;
  inline void clear_system_call();
  static const int kSystemCallFieldNumber = 8;
  inline const ::trace_format::syscall_t& system_call() const;
  inline ::trace_format::syscall_t* mutable_system_call();
  inline ::trace_format::syscall_t* release_system_call();
  inline void set_allocated_system_call(::trace_format::syscall_t* system_call);

  // optional bytes reserved_comment = 10;
  inline bool has_reserved_comment() const;
  inline void clear_reserved_comment();
  static const int kReservedCommentFieldNumber = 10;
  inline const ::std::string& reserved_comment() const;
  inline void set_reserved_comment(const ::std::string& value);
  inline void set_reserved_comment(const char* value);
  inline void set_reserved_comment(const void* value, size_t size);
  inline ::std::string* mutable_reserved_comment();
  inline ::std::string* release_reserved_comment();
  inline void set_allocated_reserved_comment(::std::string* reserved_comment);

  // @@protoc_insertion_point(class_scope:trace_format.ins_con_info_t)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_read_register();
  inline void clear_has_read_register();
  inline void set_has_write_register();
  inline void clear_has_write_register();
  inline void set_has_load_memory();
  inline void clear_has_load_memory();
  inline void set_has_store_memory();
  inline void clear_has_store_memory();
  inline void set_has_call();
  inline void clear_has_call();
  inline void set_has_ret_ret_value();
  inline void clear_has_ret_ret_value();
  inline void set_has_system_call();
  inline void clear_has_system_call();
  inline void set_has_reserved_comment();
  inline void clear_has_reserved_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::register_t* read_register_;
  ::trace_format::register_t* write_register_;
  ::trace_format::memory_t* load_memory_;
  ::trace_format::memory_t* store_memory_;
  ::trace_format::call_t* call_;
  ::trace_format::address_t* ret_ret_value_;
  ::trace_format::syscall_t* system_call_;
  ::std::string* reserved_comment_;
  int typeid__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static ins_con_info_t* default_instance_;
};
// -------------------------------------------------------------------

class instruction_t : public ::google::protobuf::Message {
 public:
  instruction_t();
  virtual ~instruction_t();

  instruction_t(const instruction_t& from);

  inline instruction_t& operator=(const instruction_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const instruction_t& default_instance();

  void Swap(instruction_t* other);

  // implements Message ----------------------------------------------

  instruction_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const instruction_t& from);
  void MergeFrom(const instruction_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 thread_id = 1;
  inline bool has_thread_id() const;
  inline void clear_thread_id();
  static const int kThreadIdFieldNumber = 1;
  inline ::google::protobuf::uint32 thread_id() const;
  inline void set_thread_id(::google::protobuf::uint32 value);

  // required .trace_format.address_t address = 2;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 2;
  inline const ::trace_format::address_t& address() const;
  inline ::trace_format::address_t* mutable_address();
  inline ::trace_format::address_t* release_address();
  inline void set_allocated_address(::trace_format::address_t* address);

  // required bytes opcode = 3;
  inline bool has_opcode() const;
  inline void clear_opcode();
  static const int kOpcodeFieldNumber = 3;
  inline const ::std::string& opcode() const;
  inline void set_opcode(const ::std::string& value);
  inline void set_opcode(const char* value);
  inline void set_opcode(const void* value, size_t size);
  inline ::std::string* mutable_opcode();
  inline ::std::string* release_opcode();
  inline void set_allocated_opcode(::std::string* opcode);

  // repeated .trace_format.ins_con_info_t concrete_info = 4;
  inline int concrete_info_size() const;
  inline void clear_concrete_info();
  static const int kConcreteInfoFieldNumber = 4;
  inline const ::trace_format::ins_con_info_t& concrete_info(int index) const;
  inline ::trace_format::ins_con_info_t* mutable_concrete_info(int index);
  inline ::trace_format::ins_con_info_t* add_concrete_info();
  inline const ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t >&
      concrete_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t >*
      mutable_concrete_info();

  // @@protoc_insertion_point(class_scope:trace_format.instruction_t)
 private:
  inline void set_has_thread_id();
  inline void clear_has_thread_id();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_opcode();
  inline void clear_has_opcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::address_t* address_;
  ::std::string* opcode_;
  ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t > concrete_info_;
  ::google::protobuf::uint32 thread_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static instruction_t* default_instance_;
};
// -------------------------------------------------------------------

class body_t : public ::google::protobuf::Message {
 public:
  body_t();
  virtual ~body_t();

  body_t(const body_t& from);

  inline body_t& operator=(const body_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const body_t& default_instance();

  void Swap(body_t* other);

  // implements Message ----------------------------------------------

  body_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const body_t& from);
  void MergeFrom(const body_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.typeid_body_t typeid = 1;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  inline ::trace_format::typeid_body_t typeid_() const;
  inline void set_typeid_(::trace_format::typeid_body_t value);

  // optional .trace_format.metadata_t metadata = 2;
  inline bool has_metadata() const;
  inline void clear_metadata();
  static const int kMetadataFieldNumber = 2;
  inline const ::trace_format::metadata_t& metadata() const;
  inline ::trace_format::metadata_t* mutable_metadata();
  inline ::trace_format::metadata_t* release_metadata();
  inline void set_allocated_metadata(::trace_format::metadata_t* metadata);

  // optional .trace_format.instruction_t instruction = 3;
  inline bool has_instruction() const;
  inline void clear_instruction();
  static const int kInstructionFieldNumber = 3;
  inline const ::trace_format::instruction_t& instruction() const;
  inline ::trace_format::instruction_t* mutable_instruction();
  inline ::trace_format::instruction_t* release_instruction();
  inline void set_allocated_instruction(::trace_format::instruction_t* instruction);

  // @@protoc_insertion_point(class_scope:trace_format.body_t)
 private:
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  inline void set_has_metadata();
  inline void clear_has_metadata();
  inline void set_has_instruction();
  inline void clear_has_instruction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::metadata_t* metadata_;
  ::trace_format::instruction_t* instruction_;
  int typeid__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static body_t* default_instance_;
};
// -------------------------------------------------------------------

class chunk_t : public ::google::protobuf::Message {
 public:
  chunk_t();
  virtual ~chunk_t();

  chunk_t(const chunk_t& from);

  inline chunk_t& operator=(const chunk_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const chunk_t& default_instance();

  void Swap(chunk_t* other);

  // implements Message ----------------------------------------------

  chunk_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const chunk_t& from);
  void MergeFrom(const chunk_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .trace_format.body_t body = 1;
  inline int body_size() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 1;
  inline const ::trace_format::body_t& body(int index) const;
  inline ::trace_format::body_t* mutable_body(int index);
  inline ::trace_format::body_t* add_body();
  inline const ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >&
      body() const;
  inline ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >*
      mutable_body();

  // @@protoc_insertion_point(class_scope:trace_format.chunk_t)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::trace_format::body_t > body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static chunk_t* default_instance_;
};
// -------------------------------------------------------------------

class trace_t : public ::google::protobuf::Message {
 public:
  trace_t();
  virtual ~trace_t();

  trace_t(const trace_t& from);

  inline trace_t& operator=(const trace_t& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const trace_t& default_instance();

  void Swap(trace_t* other);

  // implements Message ----------------------------------------------

  trace_t* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const trace_t& from);
  void MergeFrom(const trace_t& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .trace_format.header_t header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::trace_format::header_t& header() const;
  inline ::trace_format::header_t* mutable_header();
  inline ::trace_format::header_t* release_header();
  inline void set_allocated_header(::trace_format::header_t* header);

  // repeated .trace_format.body_t body = 2;
  inline int body_size() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 2;
  inline const ::trace_format::body_t& body(int index) const;
  inline ::trace_format::body_t* mutable_body(int index);
  inline ::trace_format::body_t* add_body();
  inline const ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >&
      body() const;
  inline ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >*
      mutable_body();

  // @@protoc_insertion_point(class_scope:trace_format.trace_t)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::trace_format::header_t* header_;
  ::google::protobuf::RepeatedPtrField< ::trace_format::body_t > body_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_trace_2eproto();
  friend void protobuf_AssignDesc_trace_2eproto();
  friend void protobuf_ShutdownFile_trace_2eproto();

  void InitAsDefaultInstance();
  static trace_t* default_instance_;
};
// ===================================================================


// ===================================================================

// address_t

// required .trace_format.typeid_address_t typeid = 1;
inline bool address_t::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void address_t::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void address_t::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void address_t::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::trace_format::typeid_address_t address_t::typeid_() const {
  return static_cast< ::trace_format::typeid_address_t >(typeid__);
}
inline void address_t::set_typeid_(::trace_format::typeid_address_t value) {
  assert(::trace_format::typeid_address_t_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
}

// optional uint32 value_8 = 2;
inline bool address_t::has_value_8() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void address_t::set_has_value_8() {
  _has_bits_[0] |= 0x00000002u;
}
inline void address_t::clear_has_value_8() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void address_t::clear_value_8() {
  value_8_ = 0u;
  clear_has_value_8();
}
inline ::google::protobuf::uint32 address_t::value_8() const {
  return value_8_;
}
inline void address_t::set_value_8(::google::protobuf::uint32 value) {
  set_has_value_8();
  value_8_ = value;
}

// optional uint32 value_16 = 3;
inline bool address_t::has_value_16() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void address_t::set_has_value_16() {
  _has_bits_[0] |= 0x00000004u;
}
inline void address_t::clear_has_value_16() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void address_t::clear_value_16() {
  value_16_ = 0u;
  clear_has_value_16();
}
inline ::google::protobuf::uint32 address_t::value_16() const {
  return value_16_;
}
inline void address_t::set_value_16(::google::protobuf::uint32 value) {
  set_has_value_16();
  value_16_ = value;
}

// optional uint32 value_32 = 4;
inline bool address_t::has_value_32() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void address_t::set_has_value_32() {
  _has_bits_[0] |= 0x00000008u;
}
inline void address_t::clear_has_value_32() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void address_t::clear_value_32() {
  value_32_ = 0u;
  clear_has_value_32();
}
inline ::google::protobuf::uint32 address_t::value_32() const {
  return value_32_;
}
inline void address_t::set_value_32(::google::protobuf::uint32 value) {
  set_has_value_32();
  value_32_ = value;
}

// optional uint64 value_64 = 5;
inline bool address_t::has_value_64() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void address_t::set_has_value_64() {
  _has_bits_[0] |= 0x00000010u;
}
inline void address_t::clear_has_value_64() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void address_t::clear_value_64() {
  value_64_ = GOOGLE_ULONGLONG(0);
  clear_has_value_64();
}
inline ::google::protobuf::uint64 address_t::value_64() const {
  return value_64_;
}
inline void address_t::set_value_64(::google::protobuf::uint64 value) {
  set_has_value_64();
  value_64_ = value;
}

// optional bytes value_128 = 6;
inline bool address_t::has_value_128() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void address_t::set_has_value_128() {
  _has_bits_[0] |= 0x00000020u;
}
inline void address_t::clear_has_value_128() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void address_t::clear_value_128() {
  if (value_128_ != &::google::protobuf::internal::kEmptyString) {
    value_128_->clear();
  }
  clear_has_value_128();
}
inline const ::std::string& address_t::value_128() const {
  return *value_128_;
}
inline void address_t::set_value_128(const ::std::string& value) {
  set_has_value_128();
  if (value_128_ == &::google::protobuf::internal::kEmptyString) {
    value_128_ = new ::std::string;
  }
  value_128_->assign(value);
}
inline void address_t::set_value_128(const char* value) {
  set_has_value_128();
  if (value_128_ == &::google::protobuf::internal::kEmptyString) {
    value_128_ = new ::std::string;
  }
  value_128_->assign(value);
}
inline void address_t::set_value_128(const void* value, size_t size) {
  set_has_value_128();
  if (value_128_ == &::google::protobuf::internal::kEmptyString) {
    value_128_ = new ::std::string;
  }
  value_128_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* address_t::mutable_value_128() {
  set_has_value_128();
  if (value_128_ == &::google::protobuf::internal::kEmptyString) {
    value_128_ = new ::std::string;
  }
  return value_128_;
}
inline ::std::string* address_t::release_value_128() {
  clear_has_value_128();
  if (value_128_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_128_;
    value_128_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void address_t::set_allocated_value_128(::std::string* value_128) {
  if (value_128_ != &::google::protobuf::internal::kEmptyString) {
    delete value_128_;
  }
  if (value_128) {
    set_has_value_128();
    value_128_ = value_128;
  } else {
    clear_has_value_128();
    value_128_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// header_t

// required .trace_format.architecture_t architecture = 1;
inline bool header_t::has_architecture() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void header_t::set_has_architecture() {
  _has_bits_[0] |= 0x00000001u;
}
inline void header_t::clear_has_architecture() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void header_t::clear_architecture() {
  architecture_ = 0;
  clear_has_architecture();
}
inline ::trace_format::architecture_t header_t::architecture() const {
  return static_cast< ::trace_format::architecture_t >(architecture_);
}
inline void header_t::set_architecture(::trace_format::architecture_t value) {
  assert(::trace_format::architecture_t_IsValid(value));
  set_has_architecture();
  architecture_ = value;
}

// required .trace_format.typeid_address_t address_size = 2;
inline bool header_t::has_address_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void header_t::set_has_address_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void header_t::clear_has_address_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void header_t::clear_address_size() {
  address_size_ = 0;
  clear_has_address_size();
}
inline ::trace_format::typeid_address_t header_t::address_size() const {
  return static_cast< ::trace_format::typeid_address_t >(address_size_);
}
inline void header_t::set_address_size(::trace_format::typeid_address_t value) {
  assert(::trace_format::typeid_address_t_IsValid(value));
  set_has_address_size();
  address_size_ = value;
}

// -------------------------------------------------------------------

// module_t

// required string name = 1;
inline bool module_t::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void module_t::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void module_t::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void module_t::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& module_t::name() const {
  return *name_;
}
inline void module_t::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void module_t::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void module_t::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* module_t::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* module_t::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void module_t::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// exception_t

// required uint32 type_exception = 1;
inline bool exception_t::has_type_exception() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void exception_t::set_has_type_exception() {
  _has_bits_[0] |= 0x00000001u;
}
inline void exception_t::clear_has_type_exception() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void exception_t::clear_type_exception() {
  type_exception_ = 0u;
  clear_has_type_exception();
}
inline ::google::protobuf::uint32 exception_t::type_exception() const {
  return type_exception_;
}
inline void exception_t::set_type_exception(::google::protobuf::uint32 value) {
  set_has_type_exception();
  type_exception_ = value;
}

// required .trace_format.address_t handler = 2;
inline bool exception_t::has_handler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void exception_t::set_has_handler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void exception_t::clear_has_handler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void exception_t::clear_handler() {
  if (handler_ != NULL) handler_->::trace_format::address_t::Clear();
  clear_has_handler();
}
inline const ::trace_format::address_t& exception_t::handler() const {
  return handler_ != NULL ? *handler_ : *default_instance_->handler_;
}
inline ::trace_format::address_t* exception_t::mutable_handler() {
  set_has_handler();
  if (handler_ == NULL) handler_ = new ::trace_format::address_t;
  return handler_;
}
inline ::trace_format::address_t* exception_t::release_handler() {
  clear_has_handler();
  ::trace_format::address_t* temp = handler_;
  handler_ = NULL;
  return temp;
}
inline void exception_t::set_allocated_handler(::trace_format::address_t* handler) {
  delete handler_;
  handler_ = handler;
  if (handler) {
    set_has_handler();
  } else {
    clear_has_handler();
  }
}

// -------------------------------------------------------------------

// metadata_t

// required .trace_format.typeid_metadata_t typeid = 1;
inline bool metadata_t::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void metadata_t::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void metadata_t::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void metadata_t::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::trace_format::typeid_metadata_t metadata_t::typeid_() const {
  return static_cast< ::trace_format::typeid_metadata_t >(typeid__);
}
inline void metadata_t::set_typeid_(::trace_format::typeid_metadata_t value) {
  assert(::trace_format::typeid_metadata_t_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
}

// optional .trace_format.module_t module_metadata = 2;
inline bool metadata_t::has_module_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void metadata_t::set_has_module_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void metadata_t::clear_has_module_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void metadata_t::clear_module_metadata() {
  if (module_metadata_ != NULL) module_metadata_->::trace_format::module_t::Clear();
  clear_has_module_metadata();
}
inline const ::trace_format::module_t& metadata_t::module_metadata() const {
  return module_metadata_ != NULL ? *module_metadata_ : *default_instance_->module_metadata_;
}
inline ::trace_format::module_t* metadata_t::mutable_module_metadata() {
  set_has_module_metadata();
  if (module_metadata_ == NULL) module_metadata_ = new ::trace_format::module_t;
  return module_metadata_;
}
inline ::trace_format::module_t* metadata_t::release_module_metadata() {
  clear_has_module_metadata();
  ::trace_format::module_t* temp = module_metadata_;
  module_metadata_ = NULL;
  return temp;
}
inline void metadata_t::set_allocated_module_metadata(::trace_format::module_t* module_metadata) {
  delete module_metadata_;
  module_metadata_ = module_metadata;
  if (module_metadata) {
    set_has_module_metadata();
  } else {
    clear_has_module_metadata();
  }
}

// optional .trace_format.exception_t exception_metadata = 3;
inline bool metadata_t::has_exception_metadata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void metadata_t::set_has_exception_metadata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void metadata_t::clear_has_exception_metadata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void metadata_t::clear_exception_metadata() {
  if (exception_metadata_ != NULL) exception_metadata_->::trace_format::exception_t::Clear();
  clear_has_exception_metadata();
}
inline const ::trace_format::exception_t& metadata_t::exception_metadata() const {
  return exception_metadata_ != NULL ? *exception_metadata_ : *default_instance_->exception_metadata_;
}
inline ::trace_format::exception_t* metadata_t::mutable_exception_metadata() {
  set_has_exception_metadata();
  if (exception_metadata_ == NULL) exception_metadata_ = new ::trace_format::exception_t;
  return exception_metadata_;
}
inline ::trace_format::exception_t* metadata_t::release_exception_metadata() {
  clear_has_exception_metadata();
  ::trace_format::exception_t* temp = exception_metadata_;
  exception_metadata_ = NULL;
  return temp;
}
inline void metadata_t::set_allocated_exception_metadata(::trace_format::exception_t* exception_metadata) {
  delete exception_metadata_;
  exception_metadata_ = exception_metadata;
  if (exception_metadata) {
    set_has_exception_metadata();
  } else {
    clear_has_exception_metadata();
  }
}

// optional uint32 wave_metadata = 4;
inline bool metadata_t::has_wave_metadata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void metadata_t::set_has_wave_metadata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void metadata_t::clear_has_wave_metadata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void metadata_t::clear_wave_metadata() {
  wave_metadata_ = 0u;
  clear_has_wave_metadata();
}
inline ::google::protobuf::uint32 metadata_t::wave_metadata() const {
  return wave_metadata_;
}
inline void metadata_t::set_wave_metadata(::google::protobuf::uint32 value) {
  set_has_wave_metadata();
  wave_metadata_ = value;
}

// -------------------------------------------------------------------

// register_t

// required string name = 1;
inline bool register_t::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void register_t::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void register_t::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void register_t::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& register_t::name() const {
  return *name_;
}
inline void register_t::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void register_t::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void register_t::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* register_t::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* register_t::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void register_t::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .trace_format.address_t value = 2;
inline bool register_t::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void register_t::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void register_t::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void register_t::clear_value() {
  if (value_ != NULL) value_->::trace_format::address_t::Clear();
  clear_has_value();
}
inline const ::trace_format::address_t& register_t::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::trace_format::address_t* register_t::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::trace_format::address_t;
  return value_;
}
inline ::trace_format::address_t* register_t::release_value() {
  clear_has_value();
  ::trace_format::address_t* temp = value_;
  value_ = NULL;
  return temp;
}
inline void register_t::set_allocated_value(::trace_format::address_t* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// memory_t

// required .trace_format.address_t address = 1;
inline bool memory_t::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memory_t::set_has_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void memory_t::clear_has_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void memory_t::clear_address() {
  if (address_ != NULL) address_->::trace_format::address_t::Clear();
  clear_has_address();
}
inline const ::trace_format::address_t& memory_t::address() const {
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::trace_format::address_t* memory_t::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::trace_format::address_t;
  return address_;
}
inline ::trace_format::address_t* memory_t::release_address() {
  clear_has_address();
  ::trace_format::address_t* temp = address_;
  address_ = NULL;
  return temp;
}
inline void memory_t::set_allocated_address(::trace_format::address_t* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
}

// required .trace_format.address_t value = 2;
inline bool memory_t::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memory_t::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void memory_t::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void memory_t::clear_value() {
  if (value_ != NULL) value_->::trace_format::address_t::Clear();
  clear_has_value();
}
inline const ::trace_format::address_t& memory_t::value() const {
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::trace_format::address_t* memory_t::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::trace_format::address_t;
  return value_;
}
inline ::trace_format::address_t* memory_t::release_value() {
  clear_has_value();
  ::trace_format::address_t* temp = value_;
  value_ = NULL;
  return temp;
}
inline void memory_t::set_allocated_value(::trace_format::address_t* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// call_t

// required .trace_format.address_t func_addr = 1;
inline bool call_t::has_func_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void call_t::set_has_func_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void call_t::clear_has_func_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void call_t::clear_func_addr() {
  if (func_addr_ != NULL) func_addr_->::trace_format::address_t::Clear();
  clear_has_func_addr();
}
inline const ::trace_format::address_t& call_t::func_addr() const {
  return func_addr_ != NULL ? *func_addr_ : *default_instance_->func_addr_;
}
inline ::trace_format::address_t* call_t::mutable_func_addr() {
  set_has_func_addr();
  if (func_addr_ == NULL) func_addr_ = new ::trace_format::address_t;
  return func_addr_;
}
inline ::trace_format::address_t* call_t::release_func_addr() {
  clear_has_func_addr();
  ::trace_format::address_t* temp = func_addr_;
  func_addr_ = NULL;
  return temp;
}
inline void call_t::set_allocated_func_addr(::trace_format::address_t* func_addr) {
  delete func_addr_;
  func_addr_ = func_addr;
  if (func_addr) {
    set_has_func_addr();
  } else {
    clear_has_func_addr();
  }
}

// required string func_name = 2;
inline bool call_t::has_func_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void call_t::set_has_func_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void call_t::clear_has_func_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void call_t::clear_func_name() {
  if (func_name_ != &::google::protobuf::internal::kEmptyString) {
    func_name_->clear();
  }
  clear_has_func_name();
}
inline const ::std::string& call_t::func_name() const {
  return *func_name_;
}
inline void call_t::set_func_name(const ::std::string& value) {
  set_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    func_name_ = new ::std::string;
  }
  func_name_->assign(value);
}
inline void call_t::set_func_name(const char* value) {
  set_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    func_name_ = new ::std::string;
  }
  func_name_->assign(value);
}
inline void call_t::set_func_name(const char* value, size_t size) {
  set_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    func_name_ = new ::std::string;
  }
  func_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* call_t::mutable_func_name() {
  set_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    func_name_ = new ::std::string;
  }
  return func_name_;
}
inline ::std::string* call_t::release_func_name() {
  clear_has_func_name();
  if (func_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = func_name_;
    func_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void call_t::set_allocated_func_name(::std::string* func_name) {
  if (func_name_ != &::google::protobuf::internal::kEmptyString) {
    delete func_name_;
  }
  if (func_name) {
    set_has_func_name();
    func_name_ = func_name;
  } else {
    clear_has_func_name();
    func_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool is_traced = 3;
inline bool call_t::has_is_traced() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void call_t::set_has_is_traced() {
  _has_bits_[0] |= 0x00000004u;
}
inline void call_t::clear_has_is_traced() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void call_t::clear_is_traced() {
  is_traced_ = false;
  clear_has_is_traced();
}
inline bool call_t::is_traced() const {
  return is_traced_;
}
inline void call_t::set_is_traced(bool value) {
  set_has_is_traced();
  is_traced_ = value;
}

// -------------------------------------------------------------------

// sys_open_t

// required string file_name = 1;
inline bool sys_open_t::has_file_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sys_open_t::set_has_file_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sys_open_t::clear_has_file_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sys_open_t::clear_file_name() {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    file_name_->clear();
  }
  clear_has_file_name();
}
inline const ::std::string& sys_open_t::file_name() const {
  return *file_name_;
}
inline void sys_open_t::set_file_name(const ::std::string& value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void sys_open_t::set_file_name(const char* value) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(value);
}
inline void sys_open_t::set_file_name(const char* value, size_t size) {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_open_t::mutable_file_name() {
  set_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    file_name_ = new ::std::string;
  }
  return file_name_;
}
inline ::std::string* sys_open_t::release_file_name() {
  clear_has_file_name();
  if (file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_name_;
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_open_t::set_allocated_file_name(::std::string* file_name) {
  if (file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete file_name_;
  }
  if (file_name) {
    set_has_file_name();
    file_name_ = file_name;
  } else {
    clear_has_file_name();
    file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required sint32 flags = 2;
inline bool sys_open_t::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sys_open_t::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sys_open_t::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sys_open_t::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 sys_open_t::flags() const {
  return flags_;
}
inline void sys_open_t::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
}

// required uint32 mode = 3;
inline bool sys_open_t::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sys_open_t::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sys_open_t::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sys_open_t::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 sys_open_t::mode() const {
  return mode_;
}
inline void sys_open_t::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// required int32 file_descriptor = 4;
inline bool sys_open_t::has_file_descriptor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sys_open_t::set_has_file_descriptor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sys_open_t::clear_has_file_descriptor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sys_open_t::clear_file_descriptor() {
  file_descriptor_ = 0;
  clear_has_file_descriptor();
}
inline ::google::protobuf::int32 sys_open_t::file_descriptor() const {
  return file_descriptor_;
}
inline void sys_open_t::set_file_descriptor(::google::protobuf::int32 value) {
  set_has_file_descriptor();
  file_descriptor_ = value;
}

// -------------------------------------------------------------------

// sys_read_t

// required uint32 file_descriptor = 1;
inline bool sys_read_t::has_file_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sys_read_t::set_has_file_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sys_read_t::clear_has_file_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sys_read_t::clear_file_descriptor() {
  file_descriptor_ = 0u;
  clear_has_file_descriptor();
}
inline ::google::protobuf::uint32 sys_read_t::file_descriptor() const {
  return file_descriptor_;
}
inline void sys_read_t::set_file_descriptor(::google::protobuf::uint32 value) {
  set_has_file_descriptor();
  file_descriptor_ = value;
}

// required .trace_format.address_t buffer_address = 2;
inline bool sys_read_t::has_buffer_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sys_read_t::set_has_buffer_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sys_read_t::clear_has_buffer_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sys_read_t::clear_buffer_address() {
  if (buffer_address_ != NULL) buffer_address_->::trace_format::address_t::Clear();
  clear_has_buffer_address();
}
inline const ::trace_format::address_t& sys_read_t::buffer_address() const {
  return buffer_address_ != NULL ? *buffer_address_ : *default_instance_->buffer_address_;
}
inline ::trace_format::address_t* sys_read_t::mutable_buffer_address() {
  set_has_buffer_address();
  if (buffer_address_ == NULL) buffer_address_ = new ::trace_format::address_t;
  return buffer_address_;
}
inline ::trace_format::address_t* sys_read_t::release_buffer_address() {
  clear_has_buffer_address();
  ::trace_format::address_t* temp = buffer_address_;
  buffer_address_ = NULL;
  return temp;
}
inline void sys_read_t::set_allocated_buffer_address(::trace_format::address_t* buffer_address) {
  delete buffer_address_;
  buffer_address_ = buffer_address;
  if (buffer_address) {
    set_has_buffer_address();
  } else {
    clear_has_buffer_address();
  }
}

// required uint32 count = 3;
inline bool sys_read_t::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sys_read_t::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sys_read_t::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sys_read_t::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 sys_read_t::count() const {
  return count_;
}
inline void sys_read_t::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required bytes buffer_data = 4;
inline bool sys_read_t::has_buffer_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sys_read_t::set_has_buffer_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sys_read_t::clear_has_buffer_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sys_read_t::clear_buffer_data() {
  if (buffer_data_ != &::google::protobuf::internal::kEmptyString) {
    buffer_data_->clear();
  }
  clear_has_buffer_data();
}
inline const ::std::string& sys_read_t::buffer_data() const {
  return *buffer_data_;
}
inline void sys_read_t::set_buffer_data(const ::std::string& value) {
  set_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    buffer_data_ = new ::std::string;
  }
  buffer_data_->assign(value);
}
inline void sys_read_t::set_buffer_data(const char* value) {
  set_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    buffer_data_ = new ::std::string;
  }
  buffer_data_->assign(value);
}
inline void sys_read_t::set_buffer_data(const void* value, size_t size) {
  set_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    buffer_data_ = new ::std::string;
  }
  buffer_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_read_t::mutable_buffer_data() {
  set_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    buffer_data_ = new ::std::string;
  }
  return buffer_data_;
}
inline ::std::string* sys_read_t::release_buffer_data() {
  clear_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_data_;
    buffer_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_read_t::set_allocated_buffer_data(::std::string* buffer_data) {
  if (buffer_data_ != &::google::protobuf::internal::kEmptyString) {
    delete buffer_data_;
  }
  if (buffer_data) {
    set_has_buffer_data();
    buffer_data_ = buffer_data;
  } else {
    clear_has_buffer_data();
    buffer_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 count_effective = 5;
inline bool sys_read_t::has_count_effective() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void sys_read_t::set_has_count_effective() {
  _has_bits_[0] |= 0x00000010u;
}
inline void sys_read_t::clear_has_count_effective() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void sys_read_t::clear_count_effective() {
  count_effective_ = 0u;
  clear_has_count_effective();
}
inline ::google::protobuf::uint32 sys_read_t::count_effective() const {
  return count_effective_;
}
inline void sys_read_t::set_count_effective(::google::protobuf::uint32 value) {
  set_has_count_effective();
  count_effective_ = value;
}

// -------------------------------------------------------------------

// sys_write_t

// required uint32 file_descriptor = 1;
inline bool sys_write_t::has_file_descriptor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sys_write_t::set_has_file_descriptor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sys_write_t::clear_has_file_descriptor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sys_write_t::clear_file_descriptor() {
  file_descriptor_ = 0u;
  clear_has_file_descriptor();
}
inline ::google::protobuf::uint32 sys_write_t::file_descriptor() const {
  return file_descriptor_;
}
inline void sys_write_t::set_file_descriptor(::google::protobuf::uint32 value) {
  set_has_file_descriptor();
  file_descriptor_ = value;
}

// required .trace_format.address_t buffer_address = 2;
inline bool sys_write_t::has_buffer_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sys_write_t::set_has_buffer_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sys_write_t::clear_has_buffer_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sys_write_t::clear_buffer_address() {
  if (buffer_address_ != NULL) buffer_address_->::trace_format::address_t::Clear();
  clear_has_buffer_address();
}
inline const ::trace_format::address_t& sys_write_t::buffer_address() const {
  return buffer_address_ != NULL ? *buffer_address_ : *default_instance_->buffer_address_;
}
inline ::trace_format::address_t* sys_write_t::mutable_buffer_address() {
  set_has_buffer_address();
  if (buffer_address_ == NULL) buffer_address_ = new ::trace_format::address_t;
  return buffer_address_;
}
inline ::trace_format::address_t* sys_write_t::release_buffer_address() {
  clear_has_buffer_address();
  ::trace_format::address_t* temp = buffer_address_;
  buffer_address_ = NULL;
  return temp;
}
inline void sys_write_t::set_allocated_buffer_address(::trace_format::address_t* buffer_address) {
  delete buffer_address_;
  buffer_address_ = buffer_address;
  if (buffer_address) {
    set_has_buffer_address();
  } else {
    clear_has_buffer_address();
  }
}

// required uint32 count = 3;
inline bool sys_write_t::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sys_write_t::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sys_write_t::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sys_write_t::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 sys_write_t::count() const {
  return count_;
}
inline void sys_write_t::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// required bytes buffer_data = 4;
inline bool sys_write_t::has_buffer_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sys_write_t::set_has_buffer_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sys_write_t::clear_has_buffer_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sys_write_t::clear_buffer_data() {
  if (buffer_data_ != &::google::protobuf::internal::kEmptyString) {
    buffer_data_->clear();
  }
  clear_has_buffer_data();
}
inline const ::std::string& sys_write_t::buffer_data() const {
  return *buffer_data_;
}
inline void sys_write_t::set_buffer_data(const ::std::string& value) {
  set_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    buffer_data_ = new ::std::string;
  }
  buffer_data_->assign(value);
}
inline void sys_write_t::set_buffer_data(const char* value) {
  set_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    buffer_data_ = new ::std::string;
  }
  buffer_data_->assign(value);
}
inline void sys_write_t::set_buffer_data(const void* value, size_t size) {
  set_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    buffer_data_ = new ::std::string;
  }
  buffer_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_write_t::mutable_buffer_data() {
  set_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    buffer_data_ = new ::std::string;
  }
  return buffer_data_;
}
inline ::std::string* sys_write_t::release_buffer_data() {
  clear_has_buffer_data();
  if (buffer_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buffer_data_;
    buffer_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_write_t::set_allocated_buffer_data(::std::string* buffer_data) {
  if (buffer_data_ != &::google::protobuf::internal::kEmptyString) {
    delete buffer_data_;
  }
  if (buffer_data) {
    set_has_buffer_data();
    buffer_data_ = buffer_data;
  } else {
    clear_has_buffer_data();
    buffer_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 count_effective = 5;
inline bool sys_write_t::has_count_effective() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void sys_write_t::set_has_count_effective() {
  _has_bits_[0] |= 0x00000010u;
}
inline void sys_write_t::clear_has_count_effective() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void sys_write_t::clear_count_effective() {
  count_effective_ = 0u;
  clear_has_count_effective();
}
inline ::google::protobuf::uint32 sys_write_t::count_effective() const {
  return count_effective_;
}
inline void sys_write_t::set_count_effective(::google::protobuf::uint32 value) {
  set_has_count_effective();
  count_effective_ = value;
}

// -------------------------------------------------------------------

// sys_generic_t

// required string name = 1;
inline bool sys_generic_t::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sys_generic_t::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sys_generic_t::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sys_generic_t::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& sys_generic_t::name() const {
  return *name_;
}
inline void sys_generic_t::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void sys_generic_t::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void sys_generic_t::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* sys_generic_t::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* sys_generic_t::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void sys_generic_t::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 address = 2;
inline bool sys_generic_t::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sys_generic_t::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sys_generic_t::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sys_generic_t::clear_address() {
  address_ = 0u;
  clear_has_address();
}
inline ::google::protobuf::uint32 sys_generic_t::address() const {
  return address_;
}
inline void sys_generic_t::set_address(::google::protobuf::uint32 value) {
  set_has_address();
  address_ = value;
}

// -------------------------------------------------------------------

// syscall_sup_info_t

// required .trace_format.typeid_syscall_t typeid = 1;
inline bool syscall_sup_info_t::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void syscall_sup_info_t::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void syscall_sup_info_t::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void syscall_sup_info_t::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::trace_format::typeid_syscall_t syscall_sup_info_t::typeid_() const {
  return static_cast< ::trace_format::typeid_syscall_t >(typeid__);
}
inline void syscall_sup_info_t::set_typeid_(::trace_format::typeid_syscall_t value) {
  assert(::trace_format::typeid_syscall_t_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
}

// optional .trace_format.sys_open_t open_syscall = 2;
inline bool syscall_sup_info_t::has_open_syscall() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void syscall_sup_info_t::set_has_open_syscall() {
  _has_bits_[0] |= 0x00000002u;
}
inline void syscall_sup_info_t::clear_has_open_syscall() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void syscall_sup_info_t::clear_open_syscall() {
  if (open_syscall_ != NULL) open_syscall_->::trace_format::sys_open_t::Clear();
  clear_has_open_syscall();
}
inline const ::trace_format::sys_open_t& syscall_sup_info_t::open_syscall() const {
  return open_syscall_ != NULL ? *open_syscall_ : *default_instance_->open_syscall_;
}
inline ::trace_format::sys_open_t* syscall_sup_info_t::mutable_open_syscall() {
  set_has_open_syscall();
  if (open_syscall_ == NULL) open_syscall_ = new ::trace_format::sys_open_t;
  return open_syscall_;
}
inline ::trace_format::sys_open_t* syscall_sup_info_t::release_open_syscall() {
  clear_has_open_syscall();
  ::trace_format::sys_open_t* temp = open_syscall_;
  open_syscall_ = NULL;
  return temp;
}
inline void syscall_sup_info_t::set_allocated_open_syscall(::trace_format::sys_open_t* open_syscall) {
  delete open_syscall_;
  open_syscall_ = open_syscall;
  if (open_syscall) {
    set_has_open_syscall();
  } else {
    clear_has_open_syscall();
  }
}

// optional .trace_format.sys_read_t read_syscall = 3;
inline bool syscall_sup_info_t::has_read_syscall() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void syscall_sup_info_t::set_has_read_syscall() {
  _has_bits_[0] |= 0x00000004u;
}
inline void syscall_sup_info_t::clear_has_read_syscall() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void syscall_sup_info_t::clear_read_syscall() {
  if (read_syscall_ != NULL) read_syscall_->::trace_format::sys_read_t::Clear();
  clear_has_read_syscall();
}
inline const ::trace_format::sys_read_t& syscall_sup_info_t::read_syscall() const {
  return read_syscall_ != NULL ? *read_syscall_ : *default_instance_->read_syscall_;
}
inline ::trace_format::sys_read_t* syscall_sup_info_t::mutable_read_syscall() {
  set_has_read_syscall();
  if (read_syscall_ == NULL) read_syscall_ = new ::trace_format::sys_read_t;
  return read_syscall_;
}
inline ::trace_format::sys_read_t* syscall_sup_info_t::release_read_syscall() {
  clear_has_read_syscall();
  ::trace_format::sys_read_t* temp = read_syscall_;
  read_syscall_ = NULL;
  return temp;
}
inline void syscall_sup_info_t::set_allocated_read_syscall(::trace_format::sys_read_t* read_syscall) {
  delete read_syscall_;
  read_syscall_ = read_syscall;
  if (read_syscall) {
    set_has_read_syscall();
  } else {
    clear_has_read_syscall();
  }
}

// optional .trace_format.sys_write_t write_sycall = 4;
inline bool syscall_sup_info_t::has_write_sycall() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void syscall_sup_info_t::set_has_write_sycall() {
  _has_bits_[0] |= 0x00000008u;
}
inline void syscall_sup_info_t::clear_has_write_sycall() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void syscall_sup_info_t::clear_write_sycall() {
  if (write_sycall_ != NULL) write_sycall_->::trace_format::sys_write_t::Clear();
  clear_has_write_sycall();
}
inline const ::trace_format::sys_write_t& syscall_sup_info_t::write_sycall() const {
  return write_sycall_ != NULL ? *write_sycall_ : *default_instance_->write_sycall_;
}
inline ::trace_format::sys_write_t* syscall_sup_info_t::mutable_write_sycall() {
  set_has_write_sycall();
  if (write_sycall_ == NULL) write_sycall_ = new ::trace_format::sys_write_t;
  return write_sycall_;
}
inline ::trace_format::sys_write_t* syscall_sup_info_t::release_write_sycall() {
  clear_has_write_sycall();
  ::trace_format::sys_write_t* temp = write_sycall_;
  write_sycall_ = NULL;
  return temp;
}
inline void syscall_sup_info_t::set_allocated_write_sycall(::trace_format::sys_write_t* write_sycall) {
  delete write_sycall_;
  write_sycall_ = write_sycall;
  if (write_sycall) {
    set_has_write_sycall();
  } else {
    clear_has_write_sycall();
  }
}

// optional .trace_format.sys_generic_t generic_sycall = 5;
inline bool syscall_sup_info_t::has_generic_sycall() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void syscall_sup_info_t::set_has_generic_sycall() {
  _has_bits_[0] |= 0x00000010u;
}
inline void syscall_sup_info_t::clear_has_generic_sycall() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void syscall_sup_info_t::clear_generic_sycall() {
  if (generic_sycall_ != NULL) generic_sycall_->::trace_format::sys_generic_t::Clear();
  clear_has_generic_sycall();
}
inline const ::trace_format::sys_generic_t& syscall_sup_info_t::generic_sycall() const {
  return generic_sycall_ != NULL ? *generic_sycall_ : *default_instance_->generic_sycall_;
}
inline ::trace_format::sys_generic_t* syscall_sup_info_t::mutable_generic_sycall() {
  set_has_generic_sycall();
  if (generic_sycall_ == NULL) generic_sycall_ = new ::trace_format::sys_generic_t;
  return generic_sycall_;
}
inline ::trace_format::sys_generic_t* syscall_sup_info_t::release_generic_sycall() {
  clear_has_generic_sycall();
  ::trace_format::sys_generic_t* temp = generic_sycall_;
  generic_sycall_ = NULL;
  return temp;
}
inline void syscall_sup_info_t::set_allocated_generic_sycall(::trace_format::sys_generic_t* generic_sycall) {
  delete generic_sycall_;
  generic_sycall_ = generic_sycall;
  if (generic_sycall) {
    set_has_generic_sycall();
  } else {
    clear_has_generic_sycall();
  }
}

// -------------------------------------------------------------------

// syscall_t

// required uint32 id = 1;
inline bool syscall_t::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void syscall_t::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void syscall_t::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void syscall_t::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 syscall_t::id() const {
  return id_;
}
inline void syscall_t::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .trace_format.syscall_sup_info_t info = 2;
inline bool syscall_t::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void syscall_t::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void syscall_t::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void syscall_t::clear_info() {
  if (info_ != NULL) info_->::trace_format::syscall_sup_info_t::Clear();
  clear_has_info();
}
inline const ::trace_format::syscall_sup_info_t& syscall_t::info() const {
  return info_ != NULL ? *info_ : *default_instance_->info_;
}
inline ::trace_format::syscall_sup_info_t* syscall_t::mutable_info() {
  set_has_info();
  if (info_ == NULL) info_ = new ::trace_format::syscall_sup_info_t;
  return info_;
}
inline ::trace_format::syscall_sup_info_t* syscall_t::release_info() {
  clear_has_info();
  ::trace_format::syscall_sup_info_t* temp = info_;
  info_ = NULL;
  return temp;
}
inline void syscall_t::set_allocated_info(::trace_format::syscall_sup_info_t* info) {
  delete info_;
  info_ = info;
  if (info) {
    set_has_info();
  } else {
    clear_has_info();
  }
}

// -------------------------------------------------------------------

// ins_con_info_t

// required .trace_format.typeid_con_info_t typeid = 1;
inline bool ins_con_info_t::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ins_con_info_t::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ins_con_info_t::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ins_con_info_t::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::trace_format::typeid_con_info_t ins_con_info_t::typeid_() const {
  return static_cast< ::trace_format::typeid_con_info_t >(typeid__);
}
inline void ins_con_info_t::set_typeid_(::trace_format::typeid_con_info_t value) {
  assert(::trace_format::typeid_con_info_t_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
}

// optional .trace_format.register_t read_register = 2;
inline bool ins_con_info_t::has_read_register() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ins_con_info_t::set_has_read_register() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ins_con_info_t::clear_has_read_register() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ins_con_info_t::clear_read_register() {
  if (read_register_ != NULL) read_register_->::trace_format::register_t::Clear();
  clear_has_read_register();
}
inline const ::trace_format::register_t& ins_con_info_t::read_register() const {
  return read_register_ != NULL ? *read_register_ : *default_instance_->read_register_;
}
inline ::trace_format::register_t* ins_con_info_t::mutable_read_register() {
  set_has_read_register();
  if (read_register_ == NULL) read_register_ = new ::trace_format::register_t;
  return read_register_;
}
inline ::trace_format::register_t* ins_con_info_t::release_read_register() {
  clear_has_read_register();
  ::trace_format::register_t* temp = read_register_;
  read_register_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_read_register(::trace_format::register_t* read_register) {
  delete read_register_;
  read_register_ = read_register;
  if (read_register) {
    set_has_read_register();
  } else {
    clear_has_read_register();
  }
}

// optional .trace_format.register_t write_register = 3;
inline bool ins_con_info_t::has_write_register() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ins_con_info_t::set_has_write_register() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ins_con_info_t::clear_has_write_register() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ins_con_info_t::clear_write_register() {
  if (write_register_ != NULL) write_register_->::trace_format::register_t::Clear();
  clear_has_write_register();
}
inline const ::trace_format::register_t& ins_con_info_t::write_register() const {
  return write_register_ != NULL ? *write_register_ : *default_instance_->write_register_;
}
inline ::trace_format::register_t* ins_con_info_t::mutable_write_register() {
  set_has_write_register();
  if (write_register_ == NULL) write_register_ = new ::trace_format::register_t;
  return write_register_;
}
inline ::trace_format::register_t* ins_con_info_t::release_write_register() {
  clear_has_write_register();
  ::trace_format::register_t* temp = write_register_;
  write_register_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_write_register(::trace_format::register_t* write_register) {
  delete write_register_;
  write_register_ = write_register;
  if (write_register) {
    set_has_write_register();
  } else {
    clear_has_write_register();
  }
}

// optional .trace_format.memory_t load_memory = 4;
inline bool ins_con_info_t::has_load_memory() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ins_con_info_t::set_has_load_memory() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ins_con_info_t::clear_has_load_memory() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ins_con_info_t::clear_load_memory() {
  if (load_memory_ != NULL) load_memory_->::trace_format::memory_t::Clear();
  clear_has_load_memory();
}
inline const ::trace_format::memory_t& ins_con_info_t::load_memory() const {
  return load_memory_ != NULL ? *load_memory_ : *default_instance_->load_memory_;
}
inline ::trace_format::memory_t* ins_con_info_t::mutable_load_memory() {
  set_has_load_memory();
  if (load_memory_ == NULL) load_memory_ = new ::trace_format::memory_t;
  return load_memory_;
}
inline ::trace_format::memory_t* ins_con_info_t::release_load_memory() {
  clear_has_load_memory();
  ::trace_format::memory_t* temp = load_memory_;
  load_memory_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_load_memory(::trace_format::memory_t* load_memory) {
  delete load_memory_;
  load_memory_ = load_memory;
  if (load_memory) {
    set_has_load_memory();
  } else {
    clear_has_load_memory();
  }
}

// optional .trace_format.memory_t store_memory = 5;
inline bool ins_con_info_t::has_store_memory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ins_con_info_t::set_has_store_memory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ins_con_info_t::clear_has_store_memory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ins_con_info_t::clear_store_memory() {
  if (store_memory_ != NULL) store_memory_->::trace_format::memory_t::Clear();
  clear_has_store_memory();
}
inline const ::trace_format::memory_t& ins_con_info_t::store_memory() const {
  return store_memory_ != NULL ? *store_memory_ : *default_instance_->store_memory_;
}
inline ::trace_format::memory_t* ins_con_info_t::mutable_store_memory() {
  set_has_store_memory();
  if (store_memory_ == NULL) store_memory_ = new ::trace_format::memory_t;
  return store_memory_;
}
inline ::trace_format::memory_t* ins_con_info_t::release_store_memory() {
  clear_has_store_memory();
  ::trace_format::memory_t* temp = store_memory_;
  store_memory_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_store_memory(::trace_format::memory_t* store_memory) {
  delete store_memory_;
  store_memory_ = store_memory;
  if (store_memory) {
    set_has_store_memory();
  } else {
    clear_has_store_memory();
  }
}

// optional .trace_format.call_t call = 6;
inline bool ins_con_info_t::has_call() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ins_con_info_t::set_has_call() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ins_con_info_t::clear_has_call() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ins_con_info_t::clear_call() {
  if (call_ != NULL) call_->::trace_format::call_t::Clear();
  clear_has_call();
}
inline const ::trace_format::call_t& ins_con_info_t::call() const {
  return call_ != NULL ? *call_ : *default_instance_->call_;
}
inline ::trace_format::call_t* ins_con_info_t::mutable_call() {
  set_has_call();
  if (call_ == NULL) call_ = new ::trace_format::call_t;
  return call_;
}
inline ::trace_format::call_t* ins_con_info_t::release_call() {
  clear_has_call();
  ::trace_format::call_t* temp = call_;
  call_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_call(::trace_format::call_t* call) {
  delete call_;
  call_ = call;
  if (call) {
    set_has_call();
  } else {
    clear_has_call();
  }
}

// optional .trace_format.address_t ret_ret_value = 7;
inline bool ins_con_info_t::has_ret_ret_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ins_con_info_t::set_has_ret_ret_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ins_con_info_t::clear_has_ret_ret_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ins_con_info_t::clear_ret_ret_value() {
  if (ret_ret_value_ != NULL) ret_ret_value_->::trace_format::address_t::Clear();
  clear_has_ret_ret_value();
}
inline const ::trace_format::address_t& ins_con_info_t::ret_ret_value() const {
  return ret_ret_value_ != NULL ? *ret_ret_value_ : *default_instance_->ret_ret_value_;
}
inline ::trace_format::address_t* ins_con_info_t::mutable_ret_ret_value() {
  set_has_ret_ret_value();
  if (ret_ret_value_ == NULL) ret_ret_value_ = new ::trace_format::address_t;
  return ret_ret_value_;
}
inline ::trace_format::address_t* ins_con_info_t::release_ret_ret_value() {
  clear_has_ret_ret_value();
  ::trace_format::address_t* temp = ret_ret_value_;
  ret_ret_value_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_ret_ret_value(::trace_format::address_t* ret_ret_value) {
  delete ret_ret_value_;
  ret_ret_value_ = ret_ret_value;
  if (ret_ret_value) {
    set_has_ret_ret_value();
  } else {
    clear_has_ret_ret_value();
  }
}

// optional .trace_format.syscall_t system_call = 8;
inline bool ins_con_info_t::has_system_call() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ins_con_info_t::set_has_system_call() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ins_con_info_t::clear_has_system_call() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ins_con_info_t::clear_system_call() {
  if (system_call_ != NULL) system_call_->::trace_format::syscall_t::Clear();
  clear_has_system_call();
}
inline const ::trace_format::syscall_t& ins_con_info_t::system_call() const {
  return system_call_ != NULL ? *system_call_ : *default_instance_->system_call_;
}
inline ::trace_format::syscall_t* ins_con_info_t::mutable_system_call() {
  set_has_system_call();
  if (system_call_ == NULL) system_call_ = new ::trace_format::syscall_t;
  return system_call_;
}
inline ::trace_format::syscall_t* ins_con_info_t::release_system_call() {
  clear_has_system_call();
  ::trace_format::syscall_t* temp = system_call_;
  system_call_ = NULL;
  return temp;
}
inline void ins_con_info_t::set_allocated_system_call(::trace_format::syscall_t* system_call) {
  delete system_call_;
  system_call_ = system_call;
  if (system_call) {
    set_has_system_call();
  } else {
    clear_has_system_call();
  }
}

// optional bytes reserved_comment = 10;
inline bool ins_con_info_t::has_reserved_comment() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ins_con_info_t::set_has_reserved_comment() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ins_con_info_t::clear_has_reserved_comment() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ins_con_info_t::clear_reserved_comment() {
  if (reserved_comment_ != &::google::protobuf::internal::kEmptyString) {
    reserved_comment_->clear();
  }
  clear_has_reserved_comment();
}
inline const ::std::string& ins_con_info_t::reserved_comment() const {
  return *reserved_comment_;
}
inline void ins_con_info_t::set_reserved_comment(const ::std::string& value) {
  set_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::kEmptyString) {
    reserved_comment_ = new ::std::string;
  }
  reserved_comment_->assign(value);
}
inline void ins_con_info_t::set_reserved_comment(const char* value) {
  set_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::kEmptyString) {
    reserved_comment_ = new ::std::string;
  }
  reserved_comment_->assign(value);
}
inline void ins_con_info_t::set_reserved_comment(const void* value, size_t size) {
  set_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::kEmptyString) {
    reserved_comment_ = new ::std::string;
  }
  reserved_comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ins_con_info_t::mutable_reserved_comment() {
  set_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::kEmptyString) {
    reserved_comment_ = new ::std::string;
  }
  return reserved_comment_;
}
inline ::std::string* ins_con_info_t::release_reserved_comment() {
  clear_has_reserved_comment();
  if (reserved_comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reserved_comment_;
    reserved_comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ins_con_info_t::set_allocated_reserved_comment(::std::string* reserved_comment) {
  if (reserved_comment_ != &::google::protobuf::internal::kEmptyString) {
    delete reserved_comment_;
  }
  if (reserved_comment) {
    set_has_reserved_comment();
    reserved_comment_ = reserved_comment;
  } else {
    clear_has_reserved_comment();
    reserved_comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// instruction_t

// required uint32 thread_id = 1;
inline bool instruction_t::has_thread_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void instruction_t::set_has_thread_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void instruction_t::clear_has_thread_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void instruction_t::clear_thread_id() {
  thread_id_ = 0u;
  clear_has_thread_id();
}
inline ::google::protobuf::uint32 instruction_t::thread_id() const {
  return thread_id_;
}
inline void instruction_t::set_thread_id(::google::protobuf::uint32 value) {
  set_has_thread_id();
  thread_id_ = value;
}

// required .trace_format.address_t address = 2;
inline bool instruction_t::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void instruction_t::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void instruction_t::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void instruction_t::clear_address() {
  if (address_ != NULL) address_->::trace_format::address_t::Clear();
  clear_has_address();
}
inline const ::trace_format::address_t& instruction_t::address() const {
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
inline ::trace_format::address_t* instruction_t::mutable_address() {
  set_has_address();
  if (address_ == NULL) address_ = new ::trace_format::address_t;
  return address_;
}
inline ::trace_format::address_t* instruction_t::release_address() {
  clear_has_address();
  ::trace_format::address_t* temp = address_;
  address_ = NULL;
  return temp;
}
inline void instruction_t::set_allocated_address(::trace_format::address_t* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
}

// required bytes opcode = 3;
inline bool instruction_t::has_opcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void instruction_t::set_has_opcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void instruction_t::clear_has_opcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void instruction_t::clear_opcode() {
  if (opcode_ != &::google::protobuf::internal::kEmptyString) {
    opcode_->clear();
  }
  clear_has_opcode();
}
inline const ::std::string& instruction_t::opcode() const {
  return *opcode_;
}
inline void instruction_t::set_opcode(const ::std::string& value) {
  set_has_opcode();
  if (opcode_ == &::google::protobuf::internal::kEmptyString) {
    opcode_ = new ::std::string;
  }
  opcode_->assign(value);
}
inline void instruction_t::set_opcode(const char* value) {
  set_has_opcode();
  if (opcode_ == &::google::protobuf::internal::kEmptyString) {
    opcode_ = new ::std::string;
  }
  opcode_->assign(value);
}
inline void instruction_t::set_opcode(const void* value, size_t size) {
  set_has_opcode();
  if (opcode_ == &::google::protobuf::internal::kEmptyString) {
    opcode_ = new ::std::string;
  }
  opcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* instruction_t::mutable_opcode() {
  set_has_opcode();
  if (opcode_ == &::google::protobuf::internal::kEmptyString) {
    opcode_ = new ::std::string;
  }
  return opcode_;
}
inline ::std::string* instruction_t::release_opcode() {
  clear_has_opcode();
  if (opcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opcode_;
    opcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void instruction_t::set_allocated_opcode(::std::string* opcode) {
  if (opcode_ != &::google::protobuf::internal::kEmptyString) {
    delete opcode_;
  }
  if (opcode) {
    set_has_opcode();
    opcode_ = opcode;
  } else {
    clear_has_opcode();
    opcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .trace_format.ins_con_info_t concrete_info = 4;
inline int instruction_t::concrete_info_size() const {
  return concrete_info_.size();
}
inline void instruction_t::clear_concrete_info() {
  concrete_info_.Clear();
}
inline const ::trace_format::ins_con_info_t& instruction_t::concrete_info(int index) const {
  return concrete_info_.Get(index);
}
inline ::trace_format::ins_con_info_t* instruction_t::mutable_concrete_info(int index) {
  return concrete_info_.Mutable(index);
}
inline ::trace_format::ins_con_info_t* instruction_t::add_concrete_info() {
  return concrete_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t >&
instruction_t::concrete_info() const {
  return concrete_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::trace_format::ins_con_info_t >*
instruction_t::mutable_concrete_info() {
  return &concrete_info_;
}

// -------------------------------------------------------------------

// body_t

// required .trace_format.typeid_body_t typeid = 1;
inline bool body_t::has_typeid_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void body_t::set_has_typeid_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void body_t::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void body_t::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::trace_format::typeid_body_t body_t::typeid_() const {
  return static_cast< ::trace_format::typeid_body_t >(typeid__);
}
inline void body_t::set_typeid_(::trace_format::typeid_body_t value) {
  assert(::trace_format::typeid_body_t_IsValid(value));
  set_has_typeid_();
  typeid__ = value;
}

// optional .trace_format.metadata_t metadata = 2;
inline bool body_t::has_metadata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void body_t::set_has_metadata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void body_t::clear_has_metadata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void body_t::clear_metadata() {
  if (metadata_ != NULL) metadata_->::trace_format::metadata_t::Clear();
  clear_has_metadata();
}
inline const ::trace_format::metadata_t& body_t::metadata() const {
  return metadata_ != NULL ? *metadata_ : *default_instance_->metadata_;
}
inline ::trace_format::metadata_t* body_t::mutable_metadata() {
  set_has_metadata();
  if (metadata_ == NULL) metadata_ = new ::trace_format::metadata_t;
  return metadata_;
}
inline ::trace_format::metadata_t* body_t::release_metadata() {
  clear_has_metadata();
  ::trace_format::metadata_t* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline void body_t::set_allocated_metadata(::trace_format::metadata_t* metadata) {
  delete metadata_;
  metadata_ = metadata;
  if (metadata) {
    set_has_metadata();
  } else {
    clear_has_metadata();
  }
}

// optional .trace_format.instruction_t instruction = 3;
inline bool body_t::has_instruction() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void body_t::set_has_instruction() {
  _has_bits_[0] |= 0x00000004u;
}
inline void body_t::clear_has_instruction() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void body_t::clear_instruction() {
  if (instruction_ != NULL) instruction_->::trace_format::instruction_t::Clear();
  clear_has_instruction();
}
inline const ::trace_format::instruction_t& body_t::instruction() const {
  return instruction_ != NULL ? *instruction_ : *default_instance_->instruction_;
}
inline ::trace_format::instruction_t* body_t::mutable_instruction() {
  set_has_instruction();
  if (instruction_ == NULL) instruction_ = new ::trace_format::instruction_t;
  return instruction_;
}
inline ::trace_format::instruction_t* body_t::release_instruction() {
  clear_has_instruction();
  ::trace_format::instruction_t* temp = instruction_;
  instruction_ = NULL;
  return temp;
}
inline void body_t::set_allocated_instruction(::trace_format::instruction_t* instruction) {
  delete instruction_;
  instruction_ = instruction;
  if (instruction) {
    set_has_instruction();
  } else {
    clear_has_instruction();
  }
}

// -------------------------------------------------------------------

// chunk_t

// repeated .trace_format.body_t body = 1;
inline int chunk_t::body_size() const {
  return body_.size();
}
inline void chunk_t::clear_body() {
  body_.Clear();
}
inline const ::trace_format::body_t& chunk_t::body(int index) const {
  return body_.Get(index);
}
inline ::trace_format::body_t* chunk_t::mutable_body(int index) {
  return body_.Mutable(index);
}
inline ::trace_format::body_t* chunk_t::add_body() {
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >&
chunk_t::body() const {
  return body_;
}
inline ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >*
chunk_t::mutable_body() {
  return &body_;
}

// -------------------------------------------------------------------

// trace_t

// required .trace_format.header_t header = 1;
inline bool trace_t::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void trace_t::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void trace_t::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void trace_t::clear_header() {
  if (header_ != NULL) header_->::trace_format::header_t::Clear();
  clear_has_header();
}
inline const ::trace_format::header_t& trace_t::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::trace_format::header_t* trace_t::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::trace_format::header_t;
  return header_;
}
inline ::trace_format::header_t* trace_t::release_header() {
  clear_has_header();
  ::trace_format::header_t* temp = header_;
  header_ = NULL;
  return temp;
}
inline void trace_t::set_allocated_header(::trace_format::header_t* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// repeated .trace_format.body_t body = 2;
inline int trace_t::body_size() const {
  return body_.size();
}
inline void trace_t::clear_body() {
  body_.Clear();
}
inline const ::trace_format::body_t& trace_t::body(int index) const {
  return body_.Get(index);
}
inline ::trace_format::body_t* trace_t::mutable_body(int index) {
  return body_.Mutable(index);
}
inline ::trace_format::body_t* trace_t::add_body() {
  return body_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >&
trace_t::body() const {
  return body_;
}
inline ::google::protobuf::RepeatedPtrField< ::trace_format::body_t >*
trace_t::mutable_body() {
  return &body_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace trace_format

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::architecture_t>() {
  return ::trace_format::architecture_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::typeid_address_t>() {
  return ::trace_format::typeid_address_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::typeid_metadata_t>() {
  return ::trace_format::typeid_metadata_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::typeid_syscall_t>() {
  return ::trace_format::typeid_syscall_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::typeid_con_info_t>() {
  return ::trace_format::typeid_con_info_t_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trace_format::typeid_body_t>() {
  return ::trace_format::typeid_body_t_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_trace_2eproto__INCLUDED
